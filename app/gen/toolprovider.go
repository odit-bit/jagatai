package main

import (
	"bytes"
	"fmt"
	"go/build"
	"html/template"
	"io/fs"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

const templ = `// Code generated by go generates; DO NOT EDIT !!.
package toolprovider

import (
{{- range .Imports}}
	_ "{{.}}"
{{- end}}
)
`

func main() {
	root := "./agent/toolprovider/"
	var imports = []string{}

	abs, _ := filepath.Abs(root)
	modPath := findModulePath(abs)
	if modPath == "" {
		slog.Error("no go.mod file found")
		return
	}
	slog.Info(".mod file found", "path", modPath)

	filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
		// slog.Info("walk dir", "path", path)

		if path == root {
			slog.Info("skip package", "path", path)
			return nil
		}
		if err != nil || !d.IsDir() {
			return nil
		}

		//skip vendor, testdata
		if d.Name() == "vendor" || d.Name() == "testdata" {
			return filepath.SkipDir
		}

		// verify it's go package
		pkg, err := build.ImportDir(path, build.IgnoreVendor)
		if err != nil || len(pkg.GoFiles) == 0 {
			slog.Error(err.Error())
			return nil
		}

		abs, _ := filepath.Abs(path)
		if modPath == "" {
			// it for before go mod init
			rel, _ := filepath.Rel(filepath.Dir(abs), abs)
			imports = append(imports, filepath.ToSlash(rel))
			slog.Info("add import relative", "pkg", rel)
		} else {
			rel := strings.TrimPrefix(abs, moduleRootAbs(modPath))
			imports = append(imports, filepath.ToSlash(filepath.Join(modPath, rel)))
			slog.Info("add import", "mod_path", modPath, "pkg", rel)
		}
		return nil
	})

	t := template.Must(template.New("agg").Parse(templ))
	var out bytes.Buffer

	if err := t.Execute(&out, map[string]any{"Imports": imports}); err != nil {
		fmt.Fprintf(os.Stderr, "template execute: %v\n", err)
		os.Exit(1) // Or use slog.Error()
	}
	
	os.WriteFile("agent/toolProvider/init-gen.go", out.Bytes(), 0644)
}

// func main() {
// 	root := "./agent/toolprovider"
// 	var imports []string
// 	seen := make(map[string]struct{})

// 	err := filepath.WalkDir(root, func(p string, d fs.DirEntry, err error) error {
// 		if err != nil || !d.IsDir() {
// 			return nil
// 		}

// 		// skip vendor, testdata
// 		if d.Name() == "vendor" || d.Name() == "testdata" {
// 			return filepath.SkipDir
// 		}

// 		// verify it's a go package
// 		pkg, err := build.ImportDir(p, build.IgnoreVendor)
// 		if err != nil || len(pkg.GoFiles) == 0 {
// 			return nil
// 		}

// 		abs, err := filepath.Abs(p)
// 		if err != nil {
// 			return nil
// 		}

// 		modPath := findModulePath(abs)
// 		if modPath == "" {
// 			// local package outside a module: use path relative to cwd
// 			rel, err := filepath.Rel(".", abs)
// 			if err != nil {
// 				return nil
// 			}
// 			rel = filepath.ToSlash(rel)
// 			if _, ok := seen[rel]; !ok {
// 				seen[rel] = struct{}{}
// 				imports = append(imports, rel)
// 			}
// 			return nil
// 		}

// 		modRoot := moduleRootAbs(modPath)
// 		if modRoot == "" {
// 			return nil
// 		}

// 		rel, err := filepath.Rel(modRoot, abs)
// 		if err != nil {
// 			return nil
// 		}
// 		rel = filepath.ToSlash(rel)
// 		rel = strings.TrimPrefix(rel, "/")

// 		// skip the module root package itself
// 		if rel == "" {
// 			return nil
// 		}

// 		imp := path.Join(modPath, rel)
// 		if rel == filepath.Clean(root) {
// 			return nil
// 		}
// 		if _, ok := seen[imp]; !ok {
// 			seen[imp] = struct{}{}
// 			slog.Info("add import", "import", imp, "rel", rel)
// 			imports = append(imports, imp)
// 		}
// 		return nil
// 	})
// 	if err != nil {
// 		fmt.Fprintf(os.Stderr, "walk error: %v\n", err)
// 		os.Exit(1)
// 	}

// 	t := template.Must(template.New("agg").Parse(templ))
// 	var out bytes.Buffer
// 	if err := t.Execute(&out, map[string]any{"Imports": imports}); err != nil {
// 		fmt.Fprintf(os.Stderr, "template execute: %v\n", err)
// 		os.Exit(2)
// 	}

// 	if err := os.WriteFile("agent/toolprovider/init_gen.go", out.Bytes(), 0644); err != nil {
// 		fmt.Fprintf(os.Stderr, "write file: %v\n", err)
// 		os.Exit(3)
// 	}
// }

// findModulePath walks up from dir until it finds a go.mod and returns
// the module path declared in it (e.g. "example.com/project"). If none,
// returns empty string.
func findModulePath(dir string) string {
	modFile := findGoMod(dir)
	if modFile == "" {
		return ""
	}

	// use `go list -m -f {{.Path}}` in module root for robust parse
	cmd := exec.Command("go", "list", "-m", "-f", "{{.Path}}")
	cmd.Dir = filepath.Dir(modFile)
	out, err := cmd.Output()
	if err != nil {
		// fallback: parse module line from go.mod
		b, rerr := os.ReadFile(modFile)
		if rerr != nil {
			return ""
		}
		for _, line := range strings.Split(string(b), "\n") {
			line := strings.TrimSpace(line)
			if strings.HasPrefix(line, "module") {
				return strings.TrimSpace(strings.TrimPrefix(line, "module "))
			}
		}
		return ""
	}
	return strings.TrimSpace(string(out))
}

func moduleRootAbs(modPathOrDir string) string {
	// If input looks like a filesystem dir (exists on disk), find go.mod up from it.
	if fi, err := os.Stat(modPathOrDir); err == nil && fi.IsDir() {
		modfile := findGoMod(modPathOrDir)
		if modfile == "" {
			return ""
		}
		root, _ := filepath.Abs(filepath.Dir(modfile))
		return root
	}

	// Otherwise, try to resolve module path to directory via `go list -m -json <mod>`
	cmd := exec.Command("go", "list", "-m", "-json", modPathOrDir)
	var buf bytes.Buffer
	cmd.Stdout = &buf
	if err := cmd.Run(); err != nil {
		return ""
	}

	// simple past for "Dir": "..."
	out := buf.String()
	// find  `"Dir":` field
	idx := strings.Index(out, `"Dir":`)
	if idx == -1 {
		return ""
	}
	// extract value after dir
	rest := out[idx+len(`"Dir":`):]
	rest = strings.TrimSpace(rest)
	//rest begin with "..." quoting
	if !strings.HasPrefix(rest, `"`) {
		return ""
	}
	rest = rest[1:]
	end := strings.Index(rest, `"`)
	if end == -1 {
		return ""
	}
	dir := rest[:end]
	abs, err := filepath.Abs(dir)
	if err != nil {
		return dir
	}
	return abs
}

func findGoMod(dir string) string {
	dir = filepath.Clean(dir)

	for {
		mod := filepath.Join(dir, "go.mod")
		if _, err := os.Stat(mod); err == nil {
			return mod
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return ""
		}
		dir = parent
	}
}
